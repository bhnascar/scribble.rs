<!DOCTYPE html>
<html lang="en">

<head>
    <title>Baby Pictionary - Game</title>
    <meta charset="UTF-8"/>
    <script type="text/javascript" src="/resources/host.js"></script>
    <script type="text/javascript" src="/resources/clipboard.min.js"></script>
    <script type="text/javascript" src="/resources/toolpreview.js"></script>
    <script type="text/javascript" src="/resources/reactions.js"></script>
    <link rel="stylesheet" type="text/css" href="/resources/base.css"/>
    <link rel="stylesheet" type="text/css" href="/resources/lobby.css"/>
    <link rel="icon" type="image/png" href="/resources/favicon.png"/>
</head>

<body>
<noscript><span class="noscript">Hey, seems like you've disabled JavaScript.
            I get it ... but you are trying to play an interactive drawing game
            here, so you have to turn on JavaScript.</span></noscript>
<div id="lobby">
    <span id="rounds"></span>

    <div style="position: relative">
        <div style="position: absolute">
            <!-- this button is basically behaving like a checkbox, but in order to
            have a uniform look with the other buttons in the header, we are not using
            a checkbox anymore. -->
            <button onclick="toggleSound()" class="dialog-button header-button"
                    alt="Toggle soundeffects" title="Toggle soundeffects">
                <img id="sound-toggle-label" class="header-button-image"/>
            </button>

            <button onclick="showKickDialog()" class="dialog-button header-button"
                    alt="Votekick a player" title="Votekick a player">
                <img src="/resources/kick.png" class="header-button-image"/>
            </button>

            <button onclick="showNameChangeDialog()" class="dialog-button header-button"
                    alt="Change your name" title="Change your name">
                <img src="/resources/user.svg" class="header-button-image"/>
            </button>
        </div>
        <div id="word-container" style="position:absolute;left: 50%; transform: translate(-50%, 0);"></div>
    </div>

    <span id="time-left">Time Left: ∞</span>

    <div id="player-container"></div>

    <div id="drawing-board-wrapper">
        <div id="drawing-board-inner-wrapper">
            <canvas id="drawing-board"></canvas>

            <!-- The so called "center dialogs" are divs that float above the canvas.
            They are centered are always a fraction of the canvas size but never bigger.
            The "center-dialog" is basically like a "window" if you will and the
            "center-dialog-content" is the window content. Depending on which dialog
            we want to show, we show a different content. Technically there could be more
            than one dialog visible at a time, but they'll be layered. -->
            <div id="center-dialog">
                <div id="word-dialog" class="center-dialog-content">
                    <span class="dialog-title">Choose a word</span>
                    <div class="word-button-container">
                        <button id="word-button-zero" class="dialog-button" onclick="chooseWord(0)">Placeholder</button>
                        <button id="word-button-one" class="dialog-button" onclick="chooseWord(1)">Placeholder</button>
                        <button id="word-button-two" class="dialog-button" onclick="chooseWord(2)">Placeholder</button>
                    </div>
                </div>

                <div id="start-dialog" class="center-dialog-content">
                    <span class="dialog-title">You're the host!</span>
                    <label for="name">Share this link</label>
                    <div>
                        <input id="share-link" class="dialog-button" type="text" name="name" readonly></input>
                        <button id="share-link-button" class="dialog-button" data-clipboard-target="#share-link">Copy</button>
                    </div>
                    <label class="top-spacing" for="name">Your name</label>
                    <div>
                        <input class="dialog-button username-input" type="text" name="name"></input>
                        <button class="dialog-button" onclick="startDialogChangeName()">Change</button>
                    </div>
                    <div class="top-spacing">Hit start when everyone is ready!</div>
                    <button class="dialog-button" onclick="startGame()">Start</button>
                </div>

                <div id="restart-dialog" class="center-dialog-content">
                    <span class="dialog-title">Game over!</span>
                    <div class="winner-name"></div>
                    <div class="top-spacing">Make a new lobby to start a new game!</div>
                    <div class="top-spacing">Or restart with same settings and players:</div>
                    <button class="dialog-button" onclick="startGame()">Restart</button>
                </div>

                <div id="reveal-word-dialog" class="center-dialog-content">
                    <span class="dialog-title">Time's up!</span>
                    <div>The word was...</div>
                    <div id="revealed-word" class="top-spacing"></div>
                </div>

                <div id="game-over-dialog" class="center-dialog-content">
                    <span class="dialog-title">Game over!</span>
                    <div class="winner-name"></div>
                    <div class="top-spacing" for="name">Waiting for host to restart...</div>
                    <div class="top-spacing">Or make a new lobby to host your own game!</div>
                </div>

                <div id="wait-dialog" class="center-dialog-content">
                    <span class="dialog-title">Waiting to start...</span>
                    <label for="name">Your name</label>
                    <div>
                        <input class="dialog-button username-input" type="text" name="name"></input>
                        <button class="dialog-button" onclick="waitDialogChangeName()">Change</button>
                    </div>
                </div>

                <div id="disconnected-dialog" class="center-dialog-content">
                    <span class="dialog-title">Uh oh</span>
                    <div>You've been disconnected. 😔</div>
                    <div class="top-spacing">
                        <span>Possible causes:</span>
                        <ul>
                            <li>You got kicked (you bad person, you!)</li>
                            <li>Timed out due to slothiness</li>
                            <li>The server is feeling inhospitable</li>
                        </ul>
                    </div>
                </div>

                <div id="change-name-dialog" class="center-dialog-content">
                    <span class="dialog-title">Change name</span>
                    <label for="name">Your name</label>
                    <div>
                        <input class="dialog-button username-input" type="text" name="name"></input>
                        <button class="dialog-button" onclick="nameDialogChangeName()">Change</button>
                    </div>
                    <button onclick="hideChangeNameDialog()" class="dialog-button dialog-close-button">Close</button>
                </div>

                <div id="kick-dialog" class="center-dialog-content">
                    <span class="dialog-title">Vote to kick a player</span>
                    <div id="kick-dialog-players"></div>
                    <button onclick="hideKickDialog()" class="dialog-button dialog-close-button">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div id="chat">
        <div id="message-container"></div>
        <form class="message-input-form" onsubmit="return sendMessage()">
            <input id="message-input" type="text" autocomplete="off" placeholder="Type your guess here!"/>
        </form>
    </div>
    <div id="toolbox">
        <div class="color-preview-container toolbox-group drawing-tools">
            <div id="color-preview" style="background-color: #000000 !Important"></div>
        </div>
        <div class="color-button-container toolbox-group drawing-tools">
            <!-- These buttons use !important for their color in order
            to prevent hover and active colors to appear. -->
            <div class="color-button-row">
                <button class="color-button" style="background-color: #ffffff !Important"
                        onclick="setColor('#ffffff')"></button>
                <button class="color-button" style="background-color: #c1c1c1 !Important"
                        onclick="setColor('#c1c1c1')"></button>
                <button class="color-button" style="background-color: #ef130b !Important"
                        onclick="setColor('#ef130b')"></button>
                <button class="color-button" style="background-color: #ff7100 !Important"
                        onclick="setColor('#ff7100')"></button>
                <button class="color-button" style="background-color: #ffe400 !Important"
                        onclick="setColor('#ffe400')"></button>
                <button class="color-button" style="background-color: #00cc00 !Important"
                        onclick="setColor('#00cc00')"></button>
                <button class="color-button" style="background-color: #00b2ff !Important"
                        onclick="setColor('#00b2ff')"></button>
                <button class="color-button" style="background-color: #231fd3 !Important"
                        onclick="setColor('#231fd3')"></button>
                <button class="color-button" style="background-color: #a300ba !Important"
                        onclick="setColor('#a300ba')"></button>
                <button class="color-button" style="background-color: #d37caa !Important"
                        onclick="setColor('#d37caa')"></button>
                <button class="color-button" style="background-color: #a0522d !Important"
                        onclick="setColor('#a0522d')"></button>
            </div>
            <div class="color-button-row">
                <button class="color-button" style="background-color: #000000 !Important"
                        onclick="setColor('#000000')"></button>
                <button class="color-button" style="background-color: #4c4c4c !Important"
                        onclick="setColor('#4c4c4c')"></button>
                <button class="color-button" style="background-color: #740b07 !Important"
                        onclick="setColor('#740b07')"></button>
                <button class="color-button" style="background-color: #c23800 !Important"
                        onclick="setColor('#c23800')"></button>
                <button class="color-button" style="background-color: #e8a200 !Important"
                        onclick="setColor('#e8a200')"></button>
                <button class="color-button" style="background-color: #005510 !Important"
                        onclick="setColor('#005510')"></button>
                <button class="color-button" style="background-color: #00569e !Important"
                        onclick="setColor('#00569e')"></button>
                <button class="color-button" style="background-color: #0e0865 !Important"
                        onclick="setColor('#0e0865')"></button>
                <button class="color-button" style="background-color: #550069 !Important"
                        onclick="setColor('#550069')"></button>
                <button class="color-button" style="background-color: #a75574 !Important"
                        onclick="setColor('#a75574')"></button>
                <button class="color-button" style="background-color: #63300d !Important"
                        onclick="setColor('#63300d')"></button>
            </div>
        </div>
        <div class="pencil-sizes-container toolbox-group drawing-tools">
            <label for="tool-type-pencil">
                <input id="tool-type-pencil" class="custom-check-or-radio line-width-button"
                       onchange="chooseTool(pen)" type="radio" name="tool-type" checked>
                <div class="line-width-button-content">
                    <img alt="Fill" title="Fill tool" src="/resources/pencil.png" width="40px"
                         height="40px"/>
                </div>
            </label>
            <label for="tool-type-fill">
                <input id="tool-type-fill" class="custom-check-or-radio line-width-button"
                       onchange="chooseTool(fillBucket)" type="radio" name="tool-type">
                <div class="line-width-button-content">
                    <img alt="Fill" title="Fill tool" src="/resources/bucket.png" width="40px"
                         height="40px"/>
                </div>
            </label>
            <label for="tool-type-rubber">
                <input id="tool-type-rubber" class="custom-check-or-radio line-width-button"
                       onchange="chooseTool(rubber)" type="radio" name="tool-type">
                <div class="line-width-button-content">
                    <img alt="Rubber" title="Erase tool" src="/resources/eraser.png" width="40px"
                         height="40px"/>
                </div>
            </label>
        </div>
        <div class="pencil-sizes-container toolbox-group drawing-tools">
            <label for="size8">
                <input id="size8" class="custom-check-or-radio line-width-button" onchange="setLineWidth(8)"
                       type="radio" name="line-width" checked>
                <div class="line-width-button-content">
                    <div id="size-8-button" class="dot"></div>
                </div>
            </label>
            <label for="size15">
                <input id="size15" class="custom-check-or-radio line-width-button" onchange="setLineWidth(15)"
                       type="radio" name="line-width">
                <div class="line-width-button-content">
                    <div id="size-15-button" class="dot"></div>
                </div>
            </label>
            <label for="size30">
                <input id="size30" class="custom-check-or-radio line-width-button" onchange="setLineWidth(30)"
                       type="radio" name="line-width">
                <div class="line-width-button-content">
                    <div id="size-30-button" class="dot"></div>
                </div>
            </label>
            <label for="size40">
                <input id="size40" class="custom-check-or-radio line-width-button" onchange="setLineWidth(40)"
                       type="radio" name="line-width">
                <div class="line-width-button-content">
                    <div id="size-40-button" class="dot"></div>
                </div>
            </label>
        </div>
        <div class="toolbox-group drawing-tools">
            <button class="canvas-button" onclick="clearCanvasAndSendEvent()"
                alt="Clear the canvas" title="Clear the canvas">
                <img alt="Rubber" title="Erase tool" src="/resources/trash.png" width="32px"
                         height="32px"/>
            </button>
        </div>
        <div class="pencil-sizes-container toolbox-group reaction-tools">
            <button id="thumbs-up" class="canvas-button" alt="Like" title="Like" onclick="react('👍')">👍</button>
            <button id="thumbs-down" class="canvas-button" alt="Dislike" onclick="react('👎')" title="Dislike">👎</button>
        </div>
        <div class="pencil-sizes-container toolbox-group reaction-tools">
            <button id="grin" class="canvas-button" alt="Grin" title="Grin" onclick="react('😃')">😃</button>
            <button id="rofl" class="canvas-button" alt="ROFL" title="ROFL" onclick="react('🤣')">🤣</button>
            <button id="cry" class="canvas-button" alt="Cry" title="Cry" onclick="react('😭')">😭</button>
            <button id="angry" class="canvas-button" alt="Angry" title="Angry" onclick="react('😠')">😠</button>
            <button id="roll" class="canvas-button" alt="Roll" title="Roll" onclick="react('🙄')">🙄</button>
        </div>
    </div>
</div>

<!-- Setup clipboardjs -->
<script type="text/javascript">
    const shareLink = document.getElementById("share-link");
    shareLink.value = window.location;
    new ClipboardJS('#share-link-button');
</script>

<script type="text/javascript" src="/resources/floodfill.js"></script>
<script type="text/javascript">
    console.log("Attempting Connection on port " + location.port + "...");
    let socket;
    if (location.protocol === 'https:') {
        socket = new WebSocket("wss://" + location.hostname + ":" + location.port + "/v1/ws?lobby_id={{.LobbyID}}");
    } else {
        socket = new WebSocket("ws://" + location.hostname + ":" + location.port + "/v1/ws?lobby_id={{.LobbyID}}");
    }

    const usernameInputs = document.querySelectorAll(".username-input");
    const messageInput = document.getElementById("message-input");
    const playerContainer = document.getElementById("player-container");
    const wordContainer = document.getElementById("word-container");
    const messageContainer = document.getElementById("message-container");
    const roundsSpan = document.getElementById("rounds");
    const timeLeft = document.getElementById("time-left");
    const drawingBoard = document.getElementById("drawing-board");
    const chat = document.getElementById("chat");
    const colorPreview = document.getElementById("color-preview");
    const centerDialog = document.getElementById("center-dialog");

    const startDialog = document.getElementById("start-dialog");
    const restartDialog = document.getElementById("restart-dialog");
    const gameOverDialog = document.getElementById("game-over-dialog");
    const waitDialog = document.getElementById("wait-dialog");
    const changeNameDialog = document.getElementById("change-name-dialog");
    const wordDialog = document.getElementById("word-dialog");
    const revealWordDialog = document.getElementById("reveal-word-dialog");
    const disconnectedDialog = document.getElementById("disconnected-dialog");
    const wordButtonZero = document.getElementById("word-button-zero");
    const wordButtonOne = document.getElementById("word-button-one");
    const wordButtonTwo = document.getElementById("word-button-two");

    const kickDialog = document.getElementById("kick-dialog");
    const kickDialogPlayers = document.getElementById("kick-dialog-players");

    const soundToggleLabel = document.getElementById("sound-toggle-label");
    let sound = localStorage.getItem("sound") === "true";
    updateSoundIcon();

    const board = document.getElementById("drawing-board-inner-wrapper");
    const toolPreview = new ToolPreview(board);
    const reactionSystem = new ReactionSystem(board);

    function react(reaction) {
        socket.send(JSON.stringify({
            type: "reaction",
            data: reaction,
        }));
    }

    function updateAllowDrawing(allow) {
        allowDrawing = allow;
        enableDrawingTools(allow);
        enableReactionTools(!allow);
    }

    function enableDrawingTools(enable) {
        const tools = document.getElementsByClassName("drawing-tools");
        for (let i = 0; i < tools.length; i++) {
            tools[i].style.display = (enable) ? "inherit" : "none";
        }
    }

    function enableReactionTools(enable) {
        const tools = document.getElementsByClassName("reaction-tools");
        for (let i = 0; i < tools.length; i++) {
            tools[i].style.display = (enable) ? "inherit" : "none";
        }
    }

    function showKickDialog() {
        if (cachedPlayers && cachedPlayers) {
            kickDialogPlayers.innerHTML = "";

            cachedPlayers.forEach(player => {
                //Don't wanna allow kicking ourselves.
                if (player.id !== ownID) {
                    kickDialogPlayers.innerHTML += '<button class="kick-player-button" onclick="onVotekickPlayer(\'' + player.id + '\')">' + player.name + '</button>';
                }
            });

            kickDialog.style.visibility = "visible";
        }
    }

    function hideKickDialog() {
        kickDialog.style.visibility = "hidden";
    }

    function showNameChangeDialog() {
        changeNameDialog.style.visibility = "visible";
    }

    function hideChangeNameDialog() {
        changeNameDialog.style.visibility = "hidden";
    }

    function showRevealWordDialog(word) {
        document.getElementById("revealed-word").innerHTML = '<b>' + word + '</b>';
        revealWordDialog.style.visibility = "visible";
    }

    function startDialogChangeName() {
        const choice = document.querySelector("#start-dialog .username-input").value;
        changeName(choice);
    }

    function waitDialogChangeName() {
        const choice = document.querySelector("#wait-dialog .username-input").value;
        changeName(choice);
    }

    function nameDialogChangeName() {
        const choice = document.querySelector("#change-name-dialog .username-input").value;
        changeName(choice);
    }

    function changeName(newName) {
        // Username should be cleared.
        if (newName === "") {
            document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
        } else {
            //We already persist our new username here. If the backend doesn't like it, it will reset it either way.
            //Therefore it shouldn't matter.
            document.cookie = "username=" + newName + ";expires=Tue, 19 Jan 2038 00:00:00 UTC;path=/;samesite=strict";
        }

        // Update all username input dialogs with latest username.
        usernameInputs.forEach((elem) => {
            elem.value = newName;
        });

        socket.send(JSON.stringify({
            type: "name-change",
            data: newName,
        }));
    }

    function toggleSound() {
        sound = !sound;
        localStorage.setItem("sound", sound.toString());
        updateSoundIcon();
    }

    function updateSoundIcon() {
        if (sound) {
            soundToggleLabel.src = "/resources/sound.svg";
        } else {
            soundToggleLabel.src = "/resources/no-sound.svg";
        }
    }

    //The drawing board has a base size. This base size results in a certain ratio
    //that the actual canvas has to be resized accordingly too. This is needed
    //since not every client has the same screensize.
    let baseWidth = {{.DrawingBoardBaseWidth}};
    let baseHeight = {{.DrawingBoardBaseHeight}};
    let boardRatio = baseWidth / baseHeight;

    function handleCanvasResize() {
        drawingBoard.width = drawingBoard.clientWidth;
        drawingBoard.height = drawingBoard.clientHeight;
        setLineWidth(localLineWidthUnscaled);
        chat.style.maxHeight = drawingBoard.offsetHeight + "px";
    }

    // Moving this here to extract the context after resizing
    const context = drawingBoard.getContext("2d");

    function scaleUpFactor() {
        return baseWidth / drawingBoard.clientWidth;
    }

    function scaleDownFactor() {
        return drawingBoard.clientWidth / baseWidth;
    }

    let allowDrawing;
    updateAllowDrawing(false);

    const pen = 0;
    const rubber = 1;
    const fillBucket = 2;
    chooseTool(pen);

    let localColor;
    setColor('#000000');

    let localLineWidthUnscaled;
    let localLineWidth;
    setLineWidth(8);

    //Those are not scaled for now, as the whole toolbar would then have to incorrectly size up and down.
    document.getElementById("size-8-button").style.width = 8 + "px";
    document.getElementById("size-8-button").style.height = 8 + "px";
    document.getElementById("size-15-button").style.width = 15 + "px";
    document.getElementById("size-15-button").style.height = 15 + "px";
    document.getElementById("size-30-button").style.width = 30 + "px";
    document.getElementById("size-30-button").style.height = 30 + "px";
    document.getElementById("size-40-button").style.width = 40 + "px";
    document.getElementById("size-40-button").style.height = 40 + "px";

    function startGame() {
        socket.send(JSON.stringify({
            type: "start",
        }))
        startDialog.style.visibility = "hidden";
        restartDialog.style.visibility = "hidden";
    }

    function setColor(value) {
        if (value === undefined) {
            localColor = colorPreview.style.backgroundColor;
        } else {
            localColor = value;
            colorPreview.style.backgroundColor = value;
        }
        toolPreview.setColor(localColor);
    }

    function setLineWidth(value) {
        localLineWidthUnscaled = value;
        localLineWidth = value * scaleDownFactor();
        toolPreview.setWidth(localLineWidth);
    }

    function chooseTool(value) {
        if (value === pen || value === rubber || value === fillBucket) {
            localTool = value;
        } else {
            //If this ends up with an invalid value, we use the pencil.
            localTool = pen;
        }
        toolPreview.setTool(localTool);
    }

    function hexToRgb(hex) {
        return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => '#' + r + r + g + g + b + b)
            .substring(1).match(/.{2}/g)
            .map(x => parseInt(x, 16));
    }

    function clearCanvasAndSendEvent() {
        //Avoid unnecessary traffic back to us.
        clear(context);
        socket.send(JSON.stringify({
            type: "clear-drawing-board"
        }));
    }

    const sendMessage = () => {
        socket.send(JSON.stringify({
            type: "message",
            data: messageInput.value
        }));
        messageInput.value = "";

        // Necessary in order to keep the page from submitting.
        return false;
    };

    function chooseWord(index) {
        socket.send(JSON.stringify({
            type: "choose-word",
            data: index
        }));
        updateAllowDrawing(true);
        wordDialog.style.visibility = "hidden";
    }

    function onVotekickPlayer(playerId) {
        socket.send(JSON.stringify({
            type: "kick-vote",
            data: playerId
        }));
        hideKickDialog();
    }

    let heartbeat = null;
    function startHeartbeat() {
        heartbeat = setInterval(() => {
            socket.send(JSON.stringify({
                type: "keep-alive",
                data: ""
            }));
        }, 30000);
    }

    function clearHeartbeat() {
        if (heartbeat != null) {
            clearInterval(heartbeat);
            heartbeat = null;
        }
    }

    //This automatically scrolls down the chat on arrivals of new messages
    new MutationObserver(() => messageContainer.scrollTop = messageContainer.scrollHeight)
        .observe(messageContainer, {
            attributes: false,
            childList: true,
            subtree: false
        });

    socket.onopen = () => console.log("Successfully Connected");

    let ownID, ownerID, ownName, host;
    let maxRounds = 0;
    let roundEndTime = 0;
    let guessedCorrectly = false;
    socket.onmessage = event => {
        let parsed = JSON.parse(event.data);
        if (parsed.type === "ready") {
            let ready = parsed.data;
            ownerID = ready.ownerId;
            ownName = ready.playerName;
            updateAllowDrawing(ready.drawing);
            ownID = ready.playerId;
            maxRounds = ready.maxRounds;
            roundEndTime = ready.roundEndTime;
            host = ready.host;
            applyRounds(ready.round, ready.maxRounds);

            if (ready.round === 0) {
                if (ownerID === ownID) {
                    startDialog.style.visibility = "visible";
                } else {
                    waitDialog.style.visibility = "visible";
                }
                startHeartbeat();
            }

            usernameInputs.forEach((elem) => {
                elem.value = ownName;
            });

            if (ready.players && ready.players.length) {
                applyPlayers(ready.players)
            }
            if (ready.currentDrawing && ready.currentDrawing.length) {
                applyDrawData(ready.currentDrawing)
            }
            if (ready.wordHints && ready.wordHints.length) {
                applyWordHints(ready.wordHints)
            }
        }
        if (parsed.type === "update-players") {
            applyPlayers(parsed.data);
        } else if (parsed.type === "correct-guess") {
            playWav('/resources/plop.wav');
        } else if (parsed.type === "update-wordhint") {
            applyWordHints(parsed.data);
        } else if (parsed.type === "message") {
            applyMessage("", parsed.data.author, parsed.data.content);
        } else if (parsed.type === "system-message") {
            applyMessage("system-message", host, parsed.data);
        } else if (parsed.type === "non-guessing-player-message") {
            applyMessage("non-guessing-player-message", parsed.data.author, parsed.data.content);
        } else if (parsed.type === "line") {
            drawLine(context, parsed.data.fromX * scaleDownFactor(), parsed.data.fromY * scaleDownFactor(), parsed.data.toX * scaleDownFactor(), parsed.data.toY * scaleDownFactor(), parsed.data.color, parsed.data.lineWidth * scaleDownFactor());
        } else if (parsed.type === "fill") {
            fill(context, parsed.data.x * scaleDownFactor(), parsed.data.y * scaleDownFactor(), parsed.data.color);
        } else if (parsed.type === "clear-drawing-board") {
            clear(context)
        } else if (parsed.type === "next-turn") {
            if (waitDialog.style.visibility !== "hidden") {
                waitDialog.style.visibility = "hidden";
            }
            if (gameOverDialog.style.visibility != "hidden") {
                gameOverDialog.style.visibility = "hidden";
            }
            if (revealWordDialog.style.visibility != "hidden") {
                revealWordDialog.style.visibility = "hidden";
            }

            //If a player doesn't choose, the dialog will still be up.
            wordDialog.style.visibility = "hidden";
            playWav('/resources/end-turn.wav');

            clear(context);

            roundEndTime = parsed.data.roundEndTime;
            guessedCorrectly = false;
            applyRounds(parsed.data.round, maxRounds);
            applyPlayers(parsed.data.players);

            //We clear this, since there's no word chosen right now.
            wordContainer.innerHTML = "";
            updateAllowDrawing(false);
        } else if (parsed.type === "your-turn") {
            promptWords(parsed.data[0], parsed.data[1], parsed.data[2]);
        } else if (parsed.type === "game-over") {
            const winnerNames = document.getElementsByClassName("winner-name");
            for (let i = 0; i < winnerNames.length; i++) {
                winnerNames[i].innerText = `The winner is 🥇${parsed.data}🥇`;
            }
            if (ownerID === ownID) {
                restartDialog.style.visibility = "visible";
            } else {
                gameOverDialog.style.visibility = "visible";
            }
            if (revealWordDialog.style.visibility != "hidden") {
                revealWordDialog.style.visibility = "hidden";
            }
        } else if (parsed.type === "reaction") {
            reactionSystem.react(parsed.data);
        } else if (parsed.type === "reveal-word") {
            showRevealWordDialog(parsed.data);
        }
    };

    socket.onclose = event => {
        console.log("Socket Closed Connection: ", event);
        clearHeartbeat();
        disconnectedDialog.style.visibility = "visible";
    }
    socket.onerror = error => console.log("Socket Error: ", error);

    function promptWords(wordOne, wordTwo, wordThree) {
        wordButtonZero.textContent = wordOne;
        wordButtonOne.textContent = wordTwo;
        wordButtonTwo.textContent = wordThree;
        wordDialog.style.visibility = "visible";
    }

    function playWav(file) {
        if (sound) {
            let audio = new Audio(file);
            audio.type = 'audio/wav';
            audio.play();
        }
    }

    window.setInterval(function () {
        if (roundEndTime >= 0) {
            timeLeft.innerText = "Time Left: " + Math.floor(roundEndTime / 1000);
            roundEndTime -= 500;
        } else {
            timeLeft.innerText = "Time Left: ∞";
        }
    }, 500);

    function applyMessage(styleClass, author, message) {
        if (messageContainer.childElementCount >= 100) {
            messageContainer.removeChild(messageContainer.firstChild)
        }

        messageContainer.innerHTML += `<div class="message ` + styleClass + `">
                            <span class="chat-name">` + author + `</span>
                            <span class="message-content">` + message + `</span>
                        </div>`;

        const img_src = getSticker(author, message, guessedCorrectly || allowDrawing);
        if (img_src) {
            messageContainer.innerHTML += `<img src="` + img_src + `" height="50" />`;
        }

        if (message.indexOf('correctly guessed') != -1) {
            guessedCorrectly = true;
        }
    }

    let cachedPlayers;

    function applyPlayers(players) {
        playerContainer.innerHTML = "";
        cachedPlayers = players;
        players.sort((a, b) => b.score - a.score);
        players.forEach(function (player) {
            //We don't wanna show the disconnected players.
            if (!player.connected) {
                return;
            }

            //We simply abuse the player events to get our latest name, since there's no separate event for this.
            if (player.id === ownID) {
                ownName = player.name;
            }

            let stateStyleClass;
            if (player.state === 2) {
                stateStyleClass = 'player-done';
            } else {
                stateStyleClass = '';
            }
            let newPlayerElement = '<div class="player ' + stateStyleClass + '">' +
                '<span class="rank">' + player.rank + '</span>' +
                '<div class="name-and-score">' +
                '<span class="playername';
                if (player.id === ownID) {
                    newPlayerElement += ' playername-self';
                }
                newPlayerElement +=
                '">' + player.name + '</span>' +
                '<span class="playerscore">Score: ' + player.score + '</span>';
            newPlayerElement += '</div><div class="player-status">';
            if (player.state === 1) {
                newPlayerElement += '<span id="active-drawer">✏️</span>';
            } else if (player.state === 2) {
                newPlayerElement += '<span>✔️</span>';
            }
            newPlayerElement += '</div></div>';
            if (player.rank == 1 && player.score !== 0) {
                newPlayerElement += '<div class="leader"></div>';
            }
            playerContainer.innerHTML += newPlayerElement;
        });
    }

    function applyRounds(round, maxRound) {
        roundsSpan.innerText = 'Round ' + round + ' of ' + maxRound;
    }

    function applyWordHints(wordHints) {
        wordContainer.innerHTML = "";
        //If no hint has been revealed
        wordHints.forEach(function (hint) {
            if (hint.character === 0) {
                wordContainer.innerHTML += '<span class="guess-letter guess-letter-underline">&nbsp;</span>';
            } else {
                let char = String.fromCharCode(hint.character);
                if (hint.underline) {
                    wordContainer.innerHTML += '<span class="guess-letter guess-letter-underline">' + char + '</span>'
                } else {
                    wordContainer.innerHTML += '<span class="guess-letter">' + char + '</span>';
                }
            }
        });
    }

    function applyDrawData(drawElements) {
        clear(context);
        drawElements.forEach(function (drawElement) {
            let drawData = drawElement.data;
            if (drawElement.type === "fill") {
                fill(context, drawData.x * scaleDownFactor(), drawData.y * scaleDownFactor(), drawData.color);
            } else if (drawElement.type === "line") {
                drawLine(context, drawData.fromX * scaleDownFactor(), drawData.fromY * scaleDownFactor(), drawData.toX * scaleDownFactor(), drawData.toY * scaleDownFactor(), drawData.color, drawData.lineWidth * scaleDownFactor());
            } else {
                console.log("Unknown draw element type: " + drawData.type)
            }
        });
    }

    let isDrawing = false;
    let x = 0;
    let y = 0;

    // Touch input
    let touchID = 0;

    drawingBoard.ontouchstart = function (e) {
        if (!isDrawing && allowDrawing) {
            touchID = e.touches[0].identifier;

            if (allowDrawing && localTool !== 2) {
                // calculate the offset coordinates based on client touch position and drawing board client origin
                let clientRect = drawingBoard.getBoundingClientRect();
                x = (e.touches[0].clientX - clientRect.left);
                y = (e.touches[0].clientY - clientRect.top);

                isDrawing = true;
            }
        }
    };

    drawingBoard.ontouchmove = function (e) {
        //FIXME Explanation? Does this prevent moving the page?
        e.preventDefault();

        if (allowDrawing && isDrawing) {
            // find touch with correct ID
            for (let i = e.changedTouches.length - 1; i >= 0; i--) {
                if (e.changedTouches[i].identifier === touchID) {
                    let touch = e.changedTouches[i];

                    // calculate the offset coordinates based on client touch position and drawing board client origin
                    let clientRect = drawingBoard.getBoundingClientRect();
                    let offsetX = (touch.clientX - clientRect.left);
                    let offsetY = (touch.clientY - clientRect.top);

                    // drawing functions must check for context boundaries
                    drawLineAndSendEvent(context, x, y, offsetX, offsetY, localColor, localLineWidth);
                    x = offsetX;
                    y = offsetY;

                    return;
                }
            }
        }
    };

    function onTouchEnd(e) {
        if (isDrawing) {
            // find touch with correct ID
            for (let i = e.changedTouches.length - 1; i >= 0; i--) {
                if (e.changedTouches[i].identifier === touchID) {
                    isDrawing = false;
                    return;
                }
            }
        }
    }

    drawingBoard.ontouchend = onTouchEnd;
    drawingBoard.ontouchcancel = onTouchEnd;

    // Mouse input
    drawingBoard.onmousedown = function (e) {
        if (allowDrawing && e.button === 0 && localTool !== 2) {
            let clientRect = drawingBoard.getBoundingClientRect();
            x = e.clientX - clientRect.left;
            y = e.clientY - clientRect.top;

            isDrawing = true;
        }

        return false;
    };

    // This is executed even if the mouse is not above the browser anymore.
    window.onmouseup = function (e) {
        if (isDrawing === true) {
            isDrawing = false;
        }
    };

    function mouseUpdate(e) {
        if (allowDrawing && isDrawing === true && e.button === 0) {
            // calculate the offset coordinates based on client mouse position and drawing board client origin
            let clientRect = drawingBoard.getBoundingClientRect();
            let offsetX = (e.clientX - clientRect.left);
            let offsetY = (e.clientY - clientRect.top);

            // drawing functions must check for context boundaries
            drawLineAndSendEvent(context, x, y, offsetX, offsetY, localColor, localLineWidth);
            x = offsetX;
            y = offsetY;
        }
    }

    drawingBoard.onmousemove = mouseUpdate;
    drawingBoard.onmouseleave = mouseUpdate;

    // necessary for mousemove to not use the previous exit coordinates.
    window.onmousemove = function (e) {
        let clientRect = drawingBoard.getBoundingClientRect();
        x = Math.min(clientRect.width - 1, Math.max(0, e.clientX - clientRect.left));
        y = Math.min(clientRect.height - 1, Math.max(0, e.clientY - clientRect.top));
    };

    drawingBoard.onclick = function (e) {
        if (allowDrawing && e.button === 0) {
            if (localTool === 2) {
                fillAndSendEvent(context, e.offsetX, e.offsetY, localColor)
            } else {
                drawLineAndSendEvent(context, e.offsetX, e.offsetY, e.offsetX, e.offsetY, localColor, localLineWidth);
            }
            isDrawing = false;
        }
    };

    function clear(context) {
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, drawingBoard.width, drawingBoard.height);
    }

    function fill(context, x1, y1, color) {
        context.fillStyle = color;
        //There seems to be some bug where setting the tolerance to 0 causes a freeze when painting black on white.
        context.fillFlood(x1, y1, 1);
    }

    function fillAndSendEvent(context, x1, y1, color) {
        fill(context, x1, y1, color);
        let fillInstruction = {
            type: "fill",
            data: {
                x: x1 * scaleUpFactor(),
                y: y1 * scaleUpFactor(),
                color: color
            },
        };
        socket.send(JSON.stringify(fillInstruction));
    }

    function drawLineAndSendEvent(context, x1, y1, x2, y2, color, lineWidth) {
        if (localTool === 1) {
            color = "#ffffff";
        }

        drawLine(context, x1, y1, x2, y2, color, lineWidth);

        let drawInstruction = {
            type: "line",
            data: {
                fromX: x1 * scaleUpFactor(),
                fromY: y1 * scaleUpFactor(),
                toX: x2 * scaleUpFactor(),
                toY: y2 * scaleUpFactor(),
                color: color,
                lineWidth: lineWidth * scaleUpFactor(),
            }
        };
        socket.send(JSON.stringify(drawInstruction));
    }

    function drawLine(context, x1, y1, x2, y2, color, lineWidth) {
        // the coordinates must be whole numbers to improve performance.
        // also, decimals as coordinates is not making sense.
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
        lineWidth = Math.ceil(lineWidth);

        // calculate bounding box
        let left = Math.max(0, Math.min(context.canvas.width, Math.min(x1, x2) - lineWidth));
        let top = Math.max(0, Math.min(context.canvas.height, Math.min(y1, y2) - lineWidth));
        let right = Math.max(0, Math.min(context.canvas.width, Math.max(x1, x2) + lineWidth));
        let bottom = Math.max(0, Math.min(context.canvas.height, Math.max(y1, y2) + lineWidth));

        // off canvas, so don't draw anything
        if (right - left === 0 || bottom - top === 0) {
            return;
        }

        color = hexToRgb(color);
        color[3] = 255; //alpha channel

        const circleMap = generateCircleMap(Math.floor(lineWidth / 2));
        const offset = Math.floor(circleMap.length / 2);

        const imageData = context.getImageData(left, top, right - left, bottom - top);

        for (let ix = 0; ix < circleMap.length; ix++) {
            for (let iy = 0; iy < circleMap[ix].length; iy++) {
                if (circleMap[ix][iy] === 1 || (x1 === x2 && y1 === y2 && circleMap[ix][iy] === 2)) {
                    const newX1 = x1 + ix - offset - left;
                    const newY1 = y1 + iy - offset - top;
                    const newX2 = x2 + ix - offset - left;
                    const newY2 = y2 + iy - offset - top;
                    drawBresenhamLine(imageData, newX1, newY1, newX2, newY2, color);
                }
            }
        }
        context.putImageData(imageData, left, top);
    }

    function drawBresenhamLine(imageData, x0, y0, x1, y1, color) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;

        while (true) {
            //check if pixel is inside the canvas
            if (!(x0 < 0 || x0 >= imageData.width || y0 < 0 || y0 >= imageData.height)) {
                setPixel(imageData, x0, y0, color);
            }


            if ((x0 === x1) && (y0 === y1)) break;
            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                err += dx;
                y0 += sy;
            }
        }
    }

    function generateCircleMap(radius) {
        let circleData = [];

        for (x = 0; x < 2 * radius; x++) {
            circleData[x] = [];
            for (y = 0; y < 2 * radius; y++) {
                const distanceToRadius = Math.sqrt(Math.pow(radius - x, 2) + Math.pow(radius - y, 2));
                if (distanceToRadius > radius) {
                    circleData[x][y] = 0;
                } else if (distanceToRadius < radius - 2) {
                    //optimize for performance: fill circle only when mouse was not moved
                    circleData[x][y] = 2;
                } else {
                    circleData[x][y] = 1;
                }
            }
        }

        return circleData;
    }

    function setPixel(imageData, x, y, color) {
        const offset = (y * imageData.width + x) * 4;
        imageData.data[offset] = color[0];
        imageData.data[offset + 1] = color[1];
        imageData.data[offset + 2] = color[2];
        imageData.data[offset + 3] = color[3];
    }

    //Call intially to correct initial state
    handleCanvasResize();
    window.addEventListener("resize", handleCanvasResize, false);
</script>
</body>

</html>
